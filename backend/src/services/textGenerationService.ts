// backend/src/services/textGenerationService.ts
import Anthropic from "@anthropic-ai/sdk";
import axios from "axios";
import { Text } from "@prisma/client";

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY!,
});

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY!;
const GOOGLE_CX = process.env.GOOGLE_CX || "47c4cfcb21523490f";

const LANGUAGE_MAP: Record<string, string> = {
  pl: "pl",
  en: "en",
  de: "de",
  es: "es",
  fr: "fr",
  it: "it",
  uk: "uk",
  ru: "ru",
};

async function updateTextProgress(textId: string, progress: string) {
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();
  try {
    await prisma.text.update({
      where: { id: textId },
      data: {
        progress,
        startTime: progress === "query" ? new Date() : undefined,
      },
    });
  } finally {
    await prisma.$disconnect();
  }
}

// Wysy≈Çka emaila
async function sendOrderCompletedEmail(
  email: string,
  order: { orderNumber: string; texts: Array<{ topic: string }> }
) {
  try {
    const { SESv2Client, SendEmailCommand } = await import(
      "@aws-sdk/client-sesv2"
    );

    const sesClient = new SESv2Client({
      region: process.env.AWS_REGION || "eu-north-1",
      credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
      },
    });

    // Tytu≈Ç zam√≥wienia
    const firstTopic = order.texts[0]?.topic || "Zam√≥wienie";
    const words = firstTopic.split(" ");
    const orderTitle =
      words.length <= 5 ? firstTopic : words.slice(0, 5).join(" ") + "...";

    const htmlContent = `
      <h2>Twoje zam√≥wienie jest gotowe!</h2>
      <p>Zam√≥wienie <strong>${orderTitle}</strong> zosta≈Ço uko≈Ñczone.</p>
      <p style="color: #6b7280; font-size: 14px;">(${order.orderNumber})</p>
      <p>Mo≈ºesz je pobraƒá logujƒÖc siƒô na swoje konto:</p>
      <a href="${process.env.FRONTEND_URL}/orders" style="display: inline-block; padding: 12px 24px; background: #7c3aed; color: white; text-decoration: none; border-radius: 8px; margin: 16px 0;">
        Zobacz zam√≥wienie
      </a>
      <p>Dziƒôkujemy za skorzystanie z Smart-Copy.ai!</p>
    `;

    await sesClient.send(
      new SendEmailCommand({
        FromEmailAddress: `${process.env.EMAIL_FROM_NAME || "Smart-Copy.ai"} <${
          process.env.EMAIL_FROM || "noreply@smart-copy.ai"
        }>`,
        Destination: { ToAddresses: [email] },
        Content: {
          Simple: {
            Subject: {
              Data: `Zam√≥wienie "${orderTitle}" gotowe! üéâ`,
              Charset: "UTF-8",
            },
            Body: {
              Html: { Data: htmlContent, Charset: "UTF-8" },
              Text: {
                Data: `Twoje zam√≥wienie "${orderTitle}" (${order.orderNumber}) jest gotowe! Zaloguj siƒô: ${process.env.FRONTEND_URL}/orders`,
                Charset: "UTF-8",
              },
            },
          },
        },
      })
    );

    console.log(`‚úâÔ∏è Email wys≈Çany do ${email}`);
  } catch (error) {
    console.error("‚ùå B≈ÇƒÖd wysy≈Çki emaila:", error);
  }
}

// KROK 1: Claude generuje zapytanie do Google
export async function generateGoogleQuery(text: Text): Promise<string> {
  const languageNames: Record<string, string> = {
    pl: "polski",
    en: "angielski",
    de: "niemiecki",
    es: "hiszpa≈Ñski",
    fr: "francuski",
    it: "w≈Çoski",
    uk: "ukrai≈Ñski",
    ru: "rosyjski",
  };

  const languageName = languageNames[text.language] || text.language;

  const prompt = `KRYTYCZNE: Twoje zapytanie musi byƒá TYLKO w jƒôzyku: ${languageName}
TEMAT: ${text.topic}
RODZAJ: ${text.textType}
WYTYCZNE: ${text.guidelines || "brak"}

ZASADY:
1. Zapytanie w jƒôzyku: ${languageName.toUpperCase()}
2. Kr√≥tkie (5-7 s≈Ç√≥w)
3. TYLKO zapytanie, nic wiƒôcej
4. BEZ cudzys≈Çow√≥w
5. Kluczowe s≈Çowa

TWOJE ZAPYTANIE (w jƒôzyku ${languageName}):`;

  const message = await anthropic.messages.create({
    model: "claude-3-haiku-20240307",
    max_tokens: 100,
    temperature: 0.3,
    messages: [{ role: "user", content: prompt }],
  });

  let query =
    message.content[0].type === "text" ? message.content[0].text.trim() : "";

  // ZAPISZ PROMPT I ODPOWIED≈π
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();
  await prisma.text.update({
    where: { id: text.id },
    data: {
      queryPrompt: prompt,
      queryResponse: query,
    },
  });
  await prisma.$disconnect();

  query = query
    .replace(/^(Oto zapytanie|Zapytanie|Query|–ó–∞–ø–∏—Ç|–ó–∞–ø—Ä–æ—Å)[:Ôºö]\s*/i, "")
    .replace(/^["'„Äå„Äé]|["'„Äç„Äè]$/g, "")
    .replace(/\n/g, " ")
    .trim();

  const wordCount = query.split(" ").length;
  if (wordCount > 10) {
    query = query.split(" ").slice(0, 8).join(" ");
  }

  return query;
}

// KROK 2: Wyszukiwanie w Google
export async function searchGoogle(query: string, language: string) {
  const languageCode = LANGUAGE_MAP[language] || "en";
  const allItems: any[] = [];

  for (let start = 1; start <= 11; start += 10) {
    if (allItems.length >= 15) break;

    try {
      const response = await axios.get(
        "https://www.googleapis.com/customsearch/v1",
        {
          params: {
            key: GOOGLE_API_KEY,
            cx: GOOGLE_CX,
            q: query,
            num: 10,
            hl: languageCode,
            start: start,
          },
          timeout: 10000,
        }
      );

      const items = response.data.items || [];
      allItems.push(...items);

      if (items.length < 10) break;
      await new Promise((resolve) => setTimeout(resolve, 500));
    } catch (error) {
      break;
    }
  }

  return {
    items: allItems.slice(0, 15),
    totalResults: allItems.length,
  };
}

// KROK 3: Claude wybiera najlepsze ≈∫r√≥d≈Ça
async function selectBestSources(text: any, searchResults: any[]) {
  const prompt = `Jeste≈õ ekspertem od oceny jako≈õci ≈∫r√≥de≈Ç internetowych.

ZADANIE: Przeanalizuj poni≈ºsze ≈∫r√≥d≈Ça i wybierz 3-8 NAJLEPSZYCH do napisania tekstu.

TEMAT: ${text.topic}
RODZAJ: ${text.textType}
JƒòZYK: ${text.language}

KRYTERIA WYBORU:
1. Merytoryczno≈õƒá i rzetelno≈õƒá tre≈õci
2. Zgodno≈õƒá z tematem
3. Aktualno≈õƒá informacji
4. Poziom szczeg√≥≈Çowo≈õci
5. Brak tre≈õci reklamowych/sprzeda≈ºowych

ZASADY:
- Wybierz minimum 3, maksimum 8 ≈∫r√≥de≈Ç
- Im wiƒôcej dobrych ≈∫r√≥de≈Ç, tym lepiej
- Preferuj r√≥≈ºnorodno≈õƒá perspektyw

DOSTƒòPNE ≈πR√ìD≈ÅA:
${searchResults
  .map(
    (item, index) => `
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
≈πR√ìD≈ÅO ${index + 1}:
URL: ${item.link}
Tytu≈Ç: ${item.title}
Fragment: ${item.snippet}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`
  )
  .join("\n")}

ODPOWIED≈π:
Zwr√≥ƒá TYLKO numery wybranych ≈∫r√≥de≈Ç oddzielone przecinkami (np: 1,3,5,7,9)
Bez ≈ºadnego dodatkowego tekstu!`;

  const message = await anthropic.messages.create({
    model: "claude-3-haiku-20240307",
    max_tokens: 150,
    temperature: 0.3,
    messages: [{ role: "user", content: prompt }],
  });

  const response =
    message.content[0].type === "text" ? message.content[0].text.trim() : "";

  // ZAPISZ PROMPT I ODPOWIED≈π
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();
  await prisma.text.update({
    where: { id: text.id },
    data: {
      selectPrompt: prompt,
      selectResponse: response,
    },
  });
  await prisma.$disconnect();

  const selectedNumbers = response
    .split(",")
    .map((n) => parseInt(n.trim()))
    .filter((n) => !isNaN(n) && n > 0 && n <= searchResults.length);

  if (selectedNumbers.length === 0) {
    console.warn("‚ö†Ô∏è Claude nie wybra≈Ç ≈∫r√≥de≈Ç, wybieram 3 pierwsze");
    selectedNumbers.push(1, 2, 3);
  }

  console.log(
    `‚úÖ Claude wybra≈Ç ${selectedNumbers.length} ≈∫r√≥de≈Ç: ${selectedNumbers.join(
      ", "
    )}`
  );

  return selectedNumbers.map((num) => searchResults[num - 1]);
}

// KROK 4: Scrapowanie URL-i
async function scrapeUrls(urls: string[]) {
  const SCRAPER_URL =
    process.env.SCRAPER_URL ||
    "http://scraper-najnowszy-env.eba-8usajxuv.eu-north-1.elasticbeanstalk.com";

  const results = [];
  const MAX_TOTAL_LENGTH = 150000;
  let currentTotalLength = 0;

  for (let i = 0; i < urls.length; i++) {
    const url = urls[i];

    try {
      console.log(
        `üï∑Ô∏è Scrapujƒô [${i + 1}/${urls.length}]: ${url.substring(0, 60)}...`
      );

      const response = await axios.post(
        `${SCRAPER_URL}/scrape`,
        { url },
        {
          headers: { "Content-Type": "application/json" },
          timeout: 30000,
        }
      );

      if (response.status === 200 && response.data.text) {
        let scrapedText = response.data.text;
        const originalLength = scrapedText.length;

        // OBLICZ LIMIT DLA TEGO ≈πR√ìD≈ÅA
        const remainingSources = urls.length - i;
        const remainingSpace = MAX_TOTAL_LENGTH - currentTotalLength;
        const maxForThisSource = Math.floor(remainingSpace / remainingSources);

        // PRZYTNIJ JE≈öLI ZA D≈ÅUGIE
        if (scrapedText.length > maxForThisSource) {
          scrapedText = scrapedText.substring(0, maxForThisSource);
          console.log(
            `  ‚úÇÔ∏è Przyciƒôto z ${originalLength} do ${maxForThisSource} znak√≥w`
          );
        }

        currentTotalLength += scrapedText.length;

        results.push({
          url,
          text: scrapedText,
          length: scrapedText.length,
          originalLength,
          status: "success",
        });

        console.log(
          `  ‚úÖ Zescrapowano ${scrapedText.length} znak√≥w (≈ÇƒÖcznie: ${currentTotalLength})`
        );
      } else {
        throw new Error("Invalid scraper response");
      }

      await new Promise((resolve) => setTimeout(resolve, 2000));
    } catch (error: any) {
      console.error(`  ‚ùå B≈ÇƒÖd scrapowania: ${error.message}`);
      results.push({
        url,
        text: "",
        length: 0,
        status: "failed",
        error: error.message,
      });
    }
  }

  console.log(`\nüìä PODSUMOWANIE SCRAPOWANIA:`);
  console.log(
    `  Zescrapowano: ${results.filter((r) => r.status === "success").length}/${
      urls.length
    }`
  );
  console.log(
    `  ≈ÅƒÖczna d≈Çugo≈õƒá: ${currentTotalLength} / ${MAX_TOTAL_LENGTH} znak√≥w`
  );

  return results;
}

// KROK 5: Przetwarzanie ca≈Çego zam√≥wienia
export async function processOrder(orderId: string) {
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();

  try {
    const order = await prisma.order.findUnique({
      where: { id: orderId },
      include: { texts: true },
    });

    if (!order) {
      throw new Error("Zam√≥wienie nie znalezione");
    }

    console.log(
      `\nüöÄ ROZPOCZYNAM PRZETWARZANIE ZAM√ìWIENIA ${order.orderNumber}`
    );

    for (const text of order.texts) {
      console.log(`\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
      console.log(`üìù Tekst: ${text.topic}`);
      console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);

      try {
        // ETAP 1: Claude generuje zapytanie
        console.log("üîπ ETAP 1: Generowanie zapytania Google");
        await updateTextProgress(text.id, "query");
        const googleQuery = await generateGoogleQuery(text);
        console.log(`‚úÖ Zapytanie: "${googleQuery}"\n`);

        // ETAP 2: Wyszukiwanie w Google
        console.log("üîπ ETAP 2: Wyszukiwanie w Google");
        await updateTextProgress(text.id, "search");
        const searchResults = await searchGoogle(googleQuery, text.language);
        console.log(`‚úÖ Znaleziono ${searchResults.totalResults} wynik√≥w\n`);

        // ETAP 3: Claude wybiera najlepsze ≈∫r√≥d≈Ça
        console.log("üîπ ETAP 3: Claude wybiera najlepsze ≈∫r√≥d≈Ça");
        await updateTextProgress(text.id, "select");
        const selectedSources = await selectBestSources(
          text,
          searchResults.items
        );
        const selectedUrls = selectedSources.map((s: any) => s.link);
        console.log(`‚úÖ Wybrano ${selectedUrls.length} ≈∫r√≥de≈Ç\n`);

        // ETAP 4: Zapoznawanie siƒô ze ≈∫r√≥d≈Çami
        console.log("üîπ ETAP 4: Zapoznawanie siƒô ze ≈∫r√≥d≈Çami");
        await updateTextProgress(text.id, "reading");
        const scrapedResults = await scrapeUrls(selectedUrls);

        // ZAPISZ WSZYSTKO W BAZIE
        const contentData = {
          googleQuery,
          allSearchResults: searchResults.items.map((item: any) => ({
            title: item.title,
            link: item.link,
            snippet: item.snippet,
          })),
          selectedSources: selectedSources.map((s: any) => ({
            title: s.title,
            link: s.link,
          })),
          scrapedContent: scrapedResults.map((r) => ({
            url: r.url,
            length: r.length,
            text: r.text,
            status: r.status,
          })),
        };

        await prisma.text.update({
          where: { id: text.id },
          data: {
            content: JSON.stringify(contentData, null, 2),
          },
        });

        console.log(`\n‚úÖ Tekst "${text.topic}" przetworzony pomy≈õlnie!\n`);

        // GENEROWANIE TRE≈öCI
        console.log(`üé® Rozpoczynam generowanie tre≈õci...`);
        await updateTextProgress(text.id, "writing");
        await generateContent(text.id);

        // Oznacz jako zako≈Ñczone
        await updateTextProgress(text.id, "completed");
      } catch (error: any) {
        console.error(
          `\n‚ùå B≈ÇƒÖd przetwarzania tekstu ${text.id}:`,
          error.message
        );
        await updateTextProgress(text.id, "error");
      }
    }

    console.log(`\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
    console.log(`‚úÖ ZAM√ìWIENIE ${order.orderNumber} PRZETWORZONE!`);

    // ZMIE≈É STATUS NA COMPLETED
    await prisma.order.update({
      where: { id: orderId },
      data: { status: "COMPLETED" },
    });

    console.log(`Status: COMPLETED`);
    console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);

    // WY≈öLIJ EMAIL
    try {
      const user = await prisma.user.findUnique({
        where: { id: order.userId },
      });
      if (user) {
        await sendOrderCompletedEmail(user.email, {
          orderNumber: order.orderNumber,
          texts: order.texts.map((t) => ({ topic: t.topic })),
        });
      }
    } catch (emailError) {
      console.error("‚ö†Ô∏è B≈ÇƒÖd wysy≈Çki emaila:", emailError);
    }

    return { success: true, orderId };
  } catch (error: any) {
    console.error(`‚ùå B≈ÅƒÑD PRZETWARZANIA ZAM√ìWIENIA ${orderId}:`, error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
// GENEROWANIE TRE≈öCI
// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

// WyciƒÖgnij ≈∫r√≥d≈Ça z Text.content
function extractSourcesFromText(text: any): string {
  try {
    if (!text.content) return "";
    const data = JSON.parse(text.content);
    return data.scrapedContent
      .filter((s: any) => s.status === "success")
      .map((s: any) => s.text)
      .join("\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n");
  } catch (error) {
    return "";
  }
}

// < 10 000 znak√≥w - bezpo≈õrednio pisarz
async function generateShortContent(
  text: any,
  sources: string
): Promise<string> {
  const includeIntro = text.length >= 5000;
  const prompt = `Jeste≈õ profesjonalnym copywriterem. Twoim zadaniem jest napisanie oryginalnego tekstu WY≈ÅƒÑCZNIE W FORMACIE HTML.
KRYTYCZNE ZASADY FORMATOWANIA HTML:
1. Pisz TYLKO czysty HTML - bez tag√≥w <!DOCTYPE>, <html>, <head>, <body>
2. Rozpocznij od: <h1>Tytu≈Ç Tekstu</h1>
3. ${
    includeIntro
      ? "Nastƒôpnie dodaj wstƒôp w paragrafie: <p>Wstƒôp...</p>"
      : "Po tytule przejd≈∫ BEZPO≈öREDNIO do tre≈õci g≈Ç√≥wnej"
  }
4. U≈ºywaj nag≈Ç√≥wk√≥w <h2>, <h3> do strukturyzacji
5. Ka≈ºdy akapit w tagu <p>...</p>
6. Listy w <ul><li>...</li></ul> lub <ol><li>...</li></ol>
7. Zako≈Ñcz na ostatnim znaku </p>
8. U≈ºywaj <strong> do wyr√≥≈ºnie≈Ñ, <em> do akcent√≥w

ZASADY TRE≈öCI:
1. Pisz WY≈ÅƒÑCZNIE w jƒôzyku: ${text.language}
2. ZAKAZ kopiowania ze ≈∫r√≥de≈Ç - wszystko w≈Çasnymi s≈Çowami
3. ZAKAZ kopiowania z w≈Çasnych poprzednich odpowiedzi
4. BƒÖd≈∫ oryginalny, warto≈õciowy, ciekawy
5. Pisz poprawnie gramatycznie

TEMAT: ${text.topic}
RODZAJ: ${text.textType}
D≈ÅUGO≈öƒÜ: ${text.length} znak√≥w (cel: ${text.length} ¬± 10%)
JƒòZYK: ${text.language}
${
  includeIntro
    ? "STRUKTURA: Tytu≈Ç H1 ‚Üí Wstƒôp (1 akapit) ‚Üí Tre≈õƒá g≈Ç√≥wna ‚Üí Zako≈Ñczenie"
    : "STRUKTURA: Tytu≈Ç H1 ‚Üí Tre≈õƒá g≈Ç√≥wna ‚Üí Zako≈Ñczenie"
}
WYTYCZNE: ${text.guidelines || "brak"}

≈πR√ìD≈ÅA DO WYKORZYSTANIA:
${sources}

NAPISZ ORYGINALNY TEKST W CZYSTYM HTML (zaczynajƒÖc od <h1>, ko≈ÑczƒÖc na </p>):`;

  const message = await anthropic.messages.create({
    model: "claude-3-haiku-20240307",
    max_tokens: 4000,
    temperature: 0.7,
    messages: [{ role: "user", content: prompt }],
  });

  // <<<< ZAMIE≈É STARY RETURN NA NOWY KOD >>>>
  const response =
    message.content[0].type === "text" ? message.content[0].text : "";

  // ZAPISZ PROMPTY I ODPOWIEDZI
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();

  const existingText = await prisma.text.findUnique({ where: { id: text.id } });
  const existingWriterPrompts = existingText?.writerPrompts
    ? JSON.parse(existingText.writerPrompts)
    : [];
  const existingWriterResponses = existingText?.writerResponses
    ? JSON.parse(existingText.writerResponses)
    : [];

  existingWriterPrompts.push(prompt);
  existingWriterResponses.push(response);

  await prisma.text.update({
    where: { id: text.id },
    data: {
      writerPrompts: JSON.stringify(existingWriterPrompts),
      writerResponses: JSON.stringify(existingWriterResponses),
    },
  });
  await prisma.$disconnect();

  return response;
}

// >= 10 000 znak√≥w - Kierownik okre≈õla strukturƒô
async function generateStructure(text: any): Promise<string> {
  const includeIntro = text.length >= 5000;

  const prompt = `Jeste≈õ kierownikiem projektu content. Okre≈õl strukturƒô i spis tre≈õci dla tekstu W FORMACIE HTML.

TEMAT: ${text.topic}
RODZAJ: ${text.textType}
D≈ÅUGO≈öƒÜ: ${text.length} znak√≥w
JƒòZYK: ${text.language}
WYTYCZNE: ${text.guidelines || "brak"}

FORMAT WYJ≈öCIOWY: Czysty HTML (bez <!DOCTYPE>, <html>, <body>)

ZADANIE:
Przygotuj szczeg√≥≈ÇowƒÖ strukturƒô HTML. Okre≈õl:

1. TYTU≈Å G≈Å√ìWNY (w <h1>)
${
  includeIntro
    ? "2. WSTƒòP (1 akapit, ok. 300-500 znak√≥w) - w <p>"
    : "2. BEZ WSTƒòPU - przejd≈∫ bezpo≈õrednio do tre≈õci"
}
${includeIntro ? "3." : "2."} SEKCJE G≈Å√ìWNE (w <h2>) z podsekcjami (w <h3>)
   - Okre≈õl ile znak√≥w ka≈ºda sekcja
   - Jakie punkty kluczowe
${includeIntro ? "4." : "3."} ZAKO≈ÉCZENIE (w <p>)
${includeIntro ? "5." : "4."} Ton komunikacji
${includeIntro ? "6." : "5."} Elementy HTML: <strong>, <em>, <ul>, <ol>

STRUKTURA:
<h1>Tytu≈Ç G≈Ç√≥wny</h1>
${includeIntro ? "<p>Wstƒôp wprowadzajƒÖcy... (300-500 znak√≥w)</p>" : ""}

<h2>Sekcja 1 (X znak√≥w)</h2>
<p>Tre≈õƒá sekcji 1...</p>

<h3>Podsekcja 1.1 (Y znak√≥w)</h3>
<p>Tre≈õƒá podsekcji...</p>

[...wiƒôcej sekcji...]

<p>Zako≈Ñczenie podsumowujƒÖce...</p>

Struktura musi sumowaƒá siƒô do ${text.length} znak√≥w (¬±10%).

ODPOWIED≈π - szczeg√≥≈Çowa struktura HTML:`;

  const message = await anthropic.messages.create({
    model: "claude-3-haiku-20240307",
    max_tokens: 4000,
    temperature: 0.5,
    messages: [{ role: "user", content: prompt }],
  });
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();
  await prisma.text.update({
    where: { id: text.id },
    data: {
      structurePrompt: prompt,
      structureResponse:
        message.content[0].type === "text" ? message.content[0].text : "",
    },
  });
  await prisma.$disconnect();
  return message.content[0].type === "text" ? message.content[0].text : "";
}

// Pisarz - generuje tre≈õƒá na podstawie struktury
async function generateWithStructure(
  text: any,
  structure: string,
  sources: string,
  part?: { number: number; total: number; previousContent?: string }
): Promise<string> {
  const partInfo = part
    ? `PISZESZ CZƒò≈öƒÜ ${part.number} z ${part.total}
${
  part.previousContent
    ? `\nPOPRZEDNIA CZƒò≈öƒÜ (ostatnie 5000 znak√≥w):\n${part.previousContent.substring(
        Math.max(0, part.previousContent.length - 5000)
      )}\n\nKONTYNUUJ P≈ÅYNNIE od tego miejsca:`
    : ""
}`
    : "";
  const includeIntro = text.length >= 5000;
  const prompt = `Jeste≈õ profesjonalnym copywriterem. ${partInfo}
KRYTYCZNE ZASADY FORMATOWANIA HTML:
1. Pisz TYLKO czysty HTML - bez tag√≥w <!DOCTYPE>, <html>, <head>, <body>
2. ${
    part?.number === 1
      ? "Rozpocznij od: <h1>Tytu≈Ç Tekstu</h1>"
      : "Kontynuuj strukturƒô HTML od poprzedniej czƒô≈õci"
  }
3. ${
    includeIntro && part?.number === 1
      ? "Po tytule dodaj wstƒôp: <p>Wstƒôp...</p>"
      : part?.number === 1
      ? "Po tytule przejd≈∫ BEZPO≈öREDNIO do tre≈õci"
      : ""
  }
4. U≈ºywaj nag≈Ç√≥wk√≥w <h2>, <h3> do strukturyzacji
5. Ka≈ºdy akapit w tagu <p>...</p>
6. Listy w <ul><li>...</li></ul> lub <ol><li>...</li></ol>
7. ${
    part?.number === part?.total
      ? "Zako≈Ñcz na ostatnim znaku </p>"
      : "Zako≈Ñcz czƒô≈õƒá na pe≈Çnym znaczniku (np. </p>, </li>, </ul>)"
  }
8. U≈ºywaj <strong> do wyr√≥≈ºnie≈Ñ, <em> do akcent√≥w

ZASADY TRE≈öCI:
1. Pisz WY≈ÅƒÑCZNIE w jƒôzyku: ${text.language}
2. ZAKAZ kopiowania ze ≈∫r√≥de≈Ç
3. ZAKAZ kopiowania z w≈Çasnych poprzednich odpowiedzi
4. BƒÖd≈∫ oryginalny, warto≈õciowy, ciekawy
5. ≈öcis≈Çe trzymanie siƒô struktury HTML
${
  part
    ? `6. ${
        part.previousContent
          ? "KONTYNUUJ poprzedniƒÖ czƒô≈õƒá p≈Çynnie - NIE powtarzaj tre≈õci"
          : "To jest pierwsza czƒô≈õƒá - rozpocznij od <h1>"
      }`
    : ""
}

STRUKTURA HTML DO REALIZACJI:
${structure}

≈πR√ìD≈ÅA:
${sources.substring(0, 50000)}

${
  part
    ? `NAPISZ CZƒò≈öƒÜ ${part.number}/${part.total} W CZYSTYM HTML:`
    : "NAPISZ PE≈ÅNY TEKST W CZYSTYM HTML:"
}`;

  const message = await anthropic.messages.create({
    model: "claude-3-haiku-20240307",
    max_tokens: 4000,
    temperature: 0.7,
    messages: [{ role: "user", content: prompt }],
  });

  // <<<< TUTAJ ZAMIE≈É TEN RETURN NA KOD PONI≈ªEJ >>>>
  // STARY KOD (usu≈Ñ):
  // return message.content[0].type === "text" ? message.content[0].text : "";

  // NOWY KOD:
  const response =
    message.content[0].type === "text" ? message.content[0].text : "";

  // ZAPISZ PROMPTY I ODPOWIEDZI
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();

  const existingText = await prisma.text.findUnique({ where: { id: text.id } });
  const existingWriterPrompts = existingText?.writerPrompts
    ? JSON.parse(existingText.writerPrompts)
    : [];
  const existingWriterResponses = existingText?.writerResponses
    ? JSON.parse(existingText.writerResponses)
    : [];

  existingWriterPrompts.push(prompt);
  existingWriterResponses.push(response);

  await prisma.text.update({
    where: { id: text.id },
    data: {
      writerPrompts: JSON.stringify(existingWriterPrompts),
      writerResponses: JSON.stringify(existingWriterResponses),
    },
  });
  await prisma.$disconnect();

  return response;
}

// G≈Ç√≥wna funkcja generowania tre≈õci
export async function generateContent(textId: string) {
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();

  try {
    const text = await prisma.text.findUnique({ where: { id: textId } });
    if (!text) throw new Error("Text nie znaleziony");

    console.log(`\nüé® GENEROWANIE TRE≈öCI HTML: ${text.topic}`);
    console.log(`üìè D≈Çugo≈õƒá: ${text.length} znak√≥w`);
    console.log(`${text.length >= 5000 ? "üìù Z WSTƒòPEM" : "üìù BEZ WSTƒòPU"}`);

    const sources = extractSourcesFromText(text);
    if (!sources) throw new Error("Brak ≈∫r√≥de≈Ç");

    let finalContent = "";

    // ≈öCIE≈ªKA 1: < 10 000 znak√≥w - bezpo≈õrednio pisarz
    if (text.length < 10000) {
      console.log("üìù Tryb: Bezpo≈õrednie pisanie HTML (< 10k znak√≥w)");
      finalContent = await generateShortContent(text, sources);
      console.log(`‚úÖ Wygenerowano ${finalContent.length} znak√≥w HTML`);
    }
    // ≈öCIE≈ªKA 2: 10 000 - 50 000 znak√≥w - kierownik + pisarz
    else if (text.length < 50000) {
      console.log("üìù Tryb: Kierownik + Pisarz HTML (10k-50k znak√≥w)");
      console.log("üîπ Kierownik: Tworzenie struktury HTML...");
      const structure = await generateStructure(text);
      console.log(`‚úÖ Struktura HTML utworzona`);

      console.log("üîπ Pisarz: Generowanie tre≈õci HTML...");
      finalContent = await generateWithStructure(text, structure, sources);
      console.log(`‚úÖ Wygenerowano ${finalContent.length} znak√≥w HTML`);
    }
    // ≈öCIE≈ªKA 3: 50 000 - 100 000 znak√≥w - kierownik + 2 pisarzy
    else if (text.length < 100000) {
      console.log("üìù Tryb: Kierownik + 2 Pisarzy HTML (50k-100k znak√≥w)");
      console.log("üîπ Kierownik: Tworzenie struktury HTML...");
      const structure = await generateStructure(text);
      console.log(`‚úÖ Struktura HTML utworzona`);

      console.log("üîπ Pisarz 1/2: Generowanie czƒô≈õci 1 HTML...");
      const part1 = await generateWithStructure(text, structure, sources, {
        number: 1,
        total: 2,
      });
      console.log(`‚úÖ Czƒô≈õƒá 1: ${part1.length} znak√≥w HTML`);

      console.log("üîπ Pisarz 2/2: Generowanie czƒô≈õci 2 HTML...");
      const part2 = await generateWithStructure(text, structure, sources, {
        number: 2,
        total: 2,
        previousContent: part1,
      });
      console.log(`‚úÖ Czƒô≈õƒá 2: ${part2.length} znak√≥w HTML`);

      finalContent = part1 + "\n\n" + part2;
      console.log(`‚úÖ ≈ÅƒÖcznie: ${finalContent.length} znak√≥w HTML`);
    }
    // ≈öCIE≈ªKA 4: 100 000 - 150 000 znak√≥w - kierownik + 3 pisarzy
    else {
      console.log("üìù Tryb: Kierownik + 3 Pisarzy HTML (100k-150k znak√≥w)");
      console.log("üîπ Kierownik: Tworzenie struktury HTML...");
      const structure = await generateStructure(text);
      console.log(`‚úÖ Struktura HTML utworzona`);

      console.log("üîπ Pisarz 1/3: Generowanie czƒô≈õci 1 HTML...");
      const part1 = await generateWithStructure(text, structure, sources, {
        number: 1,
        total: 3,
      });
      console.log(`‚úÖ Czƒô≈õƒá 1: ${part1.length} znak√≥w HTML`);

      console.log("üîπ Pisarz 2/3: Generowanie czƒô≈õci 2 HTML...");
      const part2 = await generateWithStructure(text, structure, sources, {
        number: 2,
        total: 3,
        previousContent: part1,
      });
      console.log(`‚úÖ Czƒô≈õƒá 2: ${part2.length} znak√≥w HTML`);

      console.log("üîπ Pisarz 3/3: Generowanie czƒô≈õci 3 HTML...");
      const part3 = await generateWithStructure(text, structure, sources, {
        number: 3,
        total: 3,
        previousContent: part1 + "\n\n" + part2,
      });
      console.log(`‚úÖ Czƒô≈õƒá 3: ${part3.length} znak√≥w HTML`);

      finalContent = part1 + "\n\n" + part2 + "\n\n" + part3;
      console.log(`‚úÖ ≈ÅƒÖcznie: ${finalContent.length} znak√≥w HTML`);
    }

    // Zapisz wygenerowanƒÖ tre≈õƒá
    const existingData = JSON.parse(text.content || "{}");
    existingData.generatedContent = finalContent;
    existingData.generatedAt = new Date().toISOString();

    await prisma.text.update({
      where: { id: textId },
      data: { content: JSON.stringify(existingData, null, 2) },
    });

    console.log(`‚úÖ TRE≈öƒÜ HTML "${text.topic}" WYGENEROWANA!\n`);
    return finalContent;
  } catch (error: any) {
    console.error(`‚ùå B≈ÇƒÖd generowania tre≈õci:`, error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

async function savePromptAndResponse(
  textId: string,
  field: string,
  prompt: string,
  response: string
) {
  const { PrismaClient } = await import("@prisma/client");
  const prisma = new PrismaClient();
  try {
    await prisma.text.update({
      where: { id: textId },
      data: { [field]: { prompt, response: response } },
    });
  } finally {
    await prisma.$disconnect();
  }
}
